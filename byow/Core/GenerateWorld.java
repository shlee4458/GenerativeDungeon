package byow.Core;
import byow.Core.BackGround.*;
import byow.Core.FixedObject.*;
import byow.Core.MovingObject.*;
import byow.Core.Graph.*;
import byow.TileEngine.*;
import java.util.*;
public class GenerateWorld {
    int width;
    int height;
    int floor;
    int numOfRooms;
    int numOfGhosts;
    int numOfFish;
    int fishObtained;
    int hp;
    TETile[][] worldState;
    Random random;
    Room room;
    Hallway hallway;
    Staircase staircase;
    Avatar avatar;
    ArrayList<Ghost> ghosts;
    ArrayList<FixedObject> fixedObjects; // existing fixedObjects on the map
    ArrayList<FixedObject> fixedObjectsCache; // cache the x, y coordinate of the fixed objects
    private static final ArrayList<String> FIXEDOBJECT = new ArrayList<>(List.of("Fish"));

    /** Constructor */
    public GenerateWorld(int width, int height, TETile[][] worldState,
                         int floor, int fishObtained, int hp, Random random) {
        this.width = width;
        this.height = height;
        this.worldState = worldState;
        this.random = random;
        this.floor = floor;
        this.ghosts = new ArrayList<>();
        this.fixedObjects = new ArrayList<>();
        this.numOfRooms = 10 + floor * 1;  // number of rooms increase by 2 for every floor
        this.numOfGhosts = Math.min(floor / 2 + 1, 4); // number of ghosts increases in every 2 floors by 1
        this.numOfFish = Math.min(numOfRooms / 5, 4); // one fish in every 6 rooms
        this.fishObtained = fishObtained;
        this.hp = hp;
        this.fixedObjectsCache = new ArrayList<>();

        fillWithBlank(worldState);
    }

    /** Fill with Nothing Tile on the map */
    public void fillWithBlank(TETile[][] tiles) {
        for (int x  = 0; x < tiles.length; x++) {
            for (int y = 0; y < tiles[0].length; y++) {
                tiles[x][y] = Tileset.NOTHING;
            }
        }
    }

    /** Generate World in the order of rooms, a staircase, hallway, an avatar, ghosts, and fixed objects */
    public TETile[][] generate() {
        generateRoom();
        generateStaircase();
        generateHallway();
        generateAvatar();
        generateGhost();
        generateFixedObjects();
        return worldState();
    }

    /** Generate rooms in the world */
    public void generateRoom() {
        /* Instantiate room object */
        room = new Room(width, height, worldState, numOfRooms, random);
        room.drawAll();
    }

    /** Generate a staircase that if stepped on by avatar, leads to the next floor */
    public void generateStaircase() {
        staircase = new Staircase(width, height, worldState, random);
        staircase.draw();
    }

    /** Generate hallways connecting rooms. Rooms are generated by getting the vertex of each room generated,
     * represented as the center of the room, and creating a Graph class with the vertex. Then finding the
     * minimum spanning tree using the kruskal`s algorithm, and pass in the KruskalMST object into the
     * constructor of the Hallway Class */
    public void generateHallway() {

        /* Instantiate hallway object */
        ArrayList<Position> Vertex = room.getVertex();
        Graph g = new Graph(Vertex);
        KruskalMST kruskal = new KruskalMST(g);
        hallway = new Hallway(worldState, room, kruskal);

        hallway.drawAll();
    }

    /** Generate an Avatar */
    public void generateAvatar() {
        avatar = new Avatar(worldState, fishObtained, hp,random);
    }

    /** Generate Ghost objects */
    public void generateGhost() {
        for (int num = 0; num < numOfGhosts; num++) {
            ghosts.add(new Ghost(worldState, random));
        }
    }

    /** Generate fixed objects on random floor tiles */
    public void generateFixedObjects() {
        for (int num = 0; num < numOfFish; num++) {
            fixedObjects.add(new Fish(worldState, random)); // generate Fish
        }

        /* Get the position of the fixed object and add to the fixedObject Map */
        for (FixedObject obj : fixedObjects) {
            fixedObjectsCache.add(obj.clone());
        }
    }

    /** Update the current state of the world. */
    public void update(int x, int y) {
        avatar.update(x, y);
        for (Ghost g : ghosts) {
            g.update(avatar.getXPos(), avatar.getYPos());
        }
    }

    /** Check if the avatar has obtained an item. If the avatar has obtained the item, remove the item
     * from the ArrayList of existing item and add it to the list of obtained items for the avatar */
    public boolean obtain() {
        for (FixedObject obj : fixedObjectsCache) {
            if (isObtain(avatar, obj)) {
                avatar.obtain(obj); // avatar obtains the item
                return true;
            }
        }
        return false;
    }

    /** Returns true if Avatar steps on the Staircase Object */
    public boolean isFloorUp() {
        return Position.samePosition(avatar.getPosition(), staircase.getPosition());
    }

    /** Returns true if Avatar steps on the fixedObject */
    public boolean isObtain(Avatar avatar, FixedObject obj) {
        return Position.samePosition(avatar.getPosition(), obj.getPosition());
    }

    /** Get instance variable, Random */
    public Random getRandom() {
        return random;
    }

    /** Get instance variable, worldState */
    public TETile[][] worldState() {
        return worldState;
    }
}
